<html>
	<head>
		<style>
			body {
				display: flex;
				align-items: center;
				justify-content: center;
				flex-direction: column;
				width: 100%;
				height: 100%;
				margin: 0;
				overflow: hidden;
			}
			#canvas {
				background: gray;
				color: white;
				border: 1px solid black;
			}
		</style>
	</head>
	<body>
		<canvas id="canvas" width="600" height="600" />
		<script>
			const COLUMNS_GAP = 5;
			const TILES_GAP = 45;
			const USER_CODE = 1;
			const COMPUTER_CODE = 2;
			const DRAW_CODE = 3;
			const EMPTY_TILE = 0;
			const INVALID_TILE = -100;
			const ROW_ORIENTATION = 1;
			const COLUMN_ORIENTATION = 2;
			const POSITIVE_DIAGONAL_ORIENTATION = 3;
			const NEGATIVE_DIAGONAL_ORIENTATION2 = 4;
			const INFINITY_RANK = 1000000;
			const LINE_LENGTH = 4;
			
			const canvas = document.getElementById("canvas");
			const canvas2d = canvas.getContext("2d");
			
			let frameWidth = canvas.width;
			let frameHeight = canvas.height;
			let rows = 6;
			let columns = 7;
			let playerTurn;
			
			function randomInt(max) {
				return Math.floor(Math.random() * max);
			}
			
			function isOutside(position) {
				return position.x < 0 || position.x >= columns || position.y < 0 || position.y >= rows;
			}
			
			function getValueSafe(tiles, position, invalidValue) {
				if (isOutside(position)) {
					return invalidValue;
				}
				
				return tiles[position.y][position.x];
			}
			
			function changePositionOrientally(position, orientation, offset) {
				if (orientation == ROW_ORIENTATION) {
					return newPosition(position.x + offset, position.y);
				} else if (orientation == COLUMN_ORIENTATION) {
					return newPosition(position.x, position.y + offset);
				} else if (orientation == POSITIVE_DIAGONAL_ORIENTATION) {
					return newPosition(position.x + offset, position.y + offset);
				} else {
					return newPosition(position.x + offset, position.y - offset);
				}
			}
			
			function newPosition(x, y) {
				return {
					x: x,
					y: y
				};
			}
			
			function initialize() {
				let tiles = []
				
				for (let y = 0; y < rows; y++) {
					let row = []
					
					for (let x = 0; x < columns; x++) {
						row[x] = EMPTY_TILE;
					}
					
					tiles.push(row)
				}
				
				return tiles;
			}
			
			function drawRoundedRect(x1, y1, width, height, angle) {
				let x2 = x1 + width;
				let y2 = y1 + height;
				
				canvas2d.beginPath();
				canvas2d.moveTo(x1 + angle, y1);
				canvas2d.lineTo(x2 - angle, y1);
				canvas2d.quadraticCurveTo(x2, y1, x2, y1 + angle);
				canvas2d.lineTo(x2, y2 - angle);
				canvas2d.quadraticCurveTo(x2, y2, x2 - angle, y2);
				canvas2d.lineTo(x1 + angle, y2);
				canvas2d.quadraticCurveTo(x1, y2, x1, y2 - angle);
				canvas2d.lineTo(x1, y1 + angle);
				canvas2d.quadraticCurveTo(x1, y1, x1 + angle, y1);
				canvas2d.stroke();
			}
			
			function drawCircle(x1, y1, width, height) {
				canvas2d.beginPath();
				canvas2d.arc(x1 + (width / 2), y1 + (height / 2), TILES_GAP, 0, 2 * Math.PI);
				canvas2d.fill();
			}
			
			function columnWidth() {
				return (frameWidth - (COLUMNS_GAP * (columns + 1))) / columns;
			}
			
			function columnLeft(x) {
				return x * columnWidth() + ((x * COLUMNS_GAP) + COLUMNS_GAP);
			}
			
			function drawColumn(x) {
				drawRoundedRect(columnLeft(x), COLUMNS_GAP, columnWidth(), frameHeight - COLUMNS_GAP * 2, 20);
			}
			
			function tileWidth() {
				return columnWidth() - (TILES_GAP * 2);
			}
			
			function tileHeight() {
				return tileWidth();
			}
			
			function tileLeft(x) {
				return columnLeft(x) + TILES_GAP;
			}
			
			function tileTop(y) {
				return frameHeight - (y * tileHeight()) - (y * TILES_GAP) - (tileHeight() + TILES_GAP);
			}
			
			function drawTile(tiles, x, y) {
				if (tiles[y][x] == EMPTY_TILE) {
					canvas2d.fillStyle = "black";
				} else if (tiles[y][x] == USER_CODE) {
					canvas2d.fillStyle = "red";
				} else if (tiles[y][x] == COMPUTER_CODE) {
					canvas2d.fillStyle = "yellow";
				}
				
				drawCircle(tileLeft(x), tileTop(y), tileWidth(), tileHeight());
				canvas2d.font = "15px David";
				canvas2d.fillStyle = "black";
				canvas2d.textAlign = "center";
				canvas2d.textBaseline = "middle";
					
			}
			
			function draw(tiles) {
				canvas2d.clearRect(0, 0, frameWidth, frameHeight);
				
				for (let x = 0; x < columns; x++) {
					drawColumn(x);
				}
				
				for (let y = 0; y < rows; y++) {
					for (let x = 0; x < columns; x++) {
						drawTile(tiles, x, y);
					}
				}
			}
			
			function switchTurn() {
				if (playerTurn == USER_CODE) {
					playerTurn = COMPUTER_CODE;
				} else {
					playerTurn = USER_CODE;
				}
			}
			
			function getTopRowForColumn(tiles, x) {
				let y = 0;
				
				while (!isOutside(newPosition(x, y)) && (tiles[y][x] != EMPTY_TILE)) {
					y = y + 1;
				}
				
				return y
			}
			
			function dropPiece(tiles, x, playerCode) {
				let y = getTopRowForColumn(tiles, x);
				
				if (isOutside(newPosition(x, y))) {
					return false;
				}
				
				tiles[y][x] = playerCode;
				return true
			}
			
			function getLineLength(tiles, position, playerCode, orientation) {
				let length = 0;
				
				while (getValueSafe(tiles, position, INVALID_TILE) == playerCode) {
					length++;
					position = changePositionOrientally(position, orientation, 1);
				}
				
				return length;
			}
			
			function isPlayerWin(tiles, playerCode) {
				for (let y = 0; y < rows; y++) {
					for (let x = 0; x < columns; x++) {
						let position = newPosition(x, y);
						
						if (getLineLength(tiles, position, playerCode, ROW_ORIENTATION) > 3 ||
							getLineLength(tiles, position, playerCode, COLUMN_ORIENTATION) > 3 ||
							getLineLength(tiles, position, playerCode, POSITIVE_DIAGONAL_ORIENTATION) > 3 ||
							getLineLength(tiles, position, playerCode, NEGATIVE_DIAGONAL_ORIENTATION2) > 3) {
							return true;
						}
					}
				}
				
				return false;
			}
			
			function isDraw(tiles) {
				for (let x = 0; x < columns; x++) {
					let y = getTopRowForColumn(tiles, x);
				
					if (!isOutside(newPosition(x, y))) {
						return false;
					}
				}
				
				return true;
			}
			
			function getLine(tiles, position, orientation) {
				let line = [0, 0, 0, 0];
				
				for (let i = 0; i < LINE_LENGTH; i++) {
					line[i] = tiles[position.y][position.x];
					position = changePositionOrientally(position, orientation, 1);
				}
				
				return line;
			}
			
			function countTileInLine(line, tileCode) {
				let count = 0;
				
				for (let i = 0; i < line.length; i++) {
					if (line[i] == tileCode) {
						count = count + 1;
					}
				}
				
				return count;
			}
			
			function evaluateLine(line, playerCode) {
				let emptyCount = countTileInLine(line, EMPTY_TILE);
				let playerCount = countTileInLine(line, playerCode);
				let opponentCount = countTileInLine(line, playerCode == COMPUTER_CODE ? USER_CODE : COMPUTER_CODE);
				
				let rank = 0;
				
				if (playerCount == 4) {
					rank += INFINITY_RANK;
				}
				
				if (playerCount == 3 && emptyCount == 1) {
					rank += 5;
				}
				
				if (playerCount == 2 && emptyCount == 2) {
					rank += 2;
				}
				
				if (opponentCount == 3 && emptyCount == 1) {
					rank -= 4;
				}
				
				if (opponentCount == 4) {
					rank -= INFINITY_RANK;
				}
				
				return rank;
			}
			
			function evaluateBoard(tiles, playerCode) {
				let rank = 0;
				let middleColumn = Math.floor(columns / 2)
				
				for (let y = 0; y < rows; y++) {
					if (tiles[y][middleColumn] == playerCode) {
						rank += 1;
					}
				}
				
				for (let y = 0; y < rows; y++) {
					for (let x = 0; x < columns - (LINE_LENGTH - 1); x++) {
						let position = newPosition(x, y);
						let line = getLine(tiles, position, ROW_ORIENTATION);
						let lineRank = evaluateLine(line, playerCode);
						rank += lineRank;
					}
				}
				
				for (let y = 0; y < rows - (LINE_LENGTH - 1); y++) {
					for (let x = 0; x < columns; x++) {
						let position = newPosition(x, y);
						let line = getLine(tiles, position, COLUMN_ORIENTATION);
						let lineRank = evaluateLine(line, playerCode);
						rank += lineRank;
					}
				}
				
				for (let y = 0; y < rows - (LINE_LENGTH - 1); y++) {
					for (let x = 0; x < columns - (LINE_LENGTH - 1); x++) {
						let position = newPosition(x, y);
						let line = getLine(tiles, position, POSITIVE_DIAGONAL_ORIENTATION);
						let lineRank = evaluateLine(line, playerCode);
						rank += lineRank;
					}
				}
				
				for (let y = rows - (LINE_LENGTH - 1); y < rows; y++) {
					for (let x = 0; x < columns - (LINE_LENGTH - 1); x++) {
						let position = newPosition(x, y);
						let line = getLine(tiles, position, NEGATIVE_DIAGONAL_ORIENTATION2);
						let lineRank = evaluateLine(line, playerCode);
						rank += lineRank;
					}
				}
				
				return rank;
			}
			
			function cloneTiles(tiles) {
				let result = []
				
				for (let y = 0; y < rows; y++) {
					let row = []
					
					for (let x = 0; x < columns; x++) {
						row.push(tiles[y][x]);
					}
					
					result.push(row)
				}
				
				return result;
			}
			
			function minimax(tiles, depth, maximizingPlayer, playerCode) {
				let result = {
					rank: 0,
					column: 0
				};
				
				if (depth == 0 || isPlayerWin(tiles, maximizingPlayer ? USER_CODE : COMPUTER_CODE)) {
					result.rank = evaluateBoard(tiles, playerCode);
					return result;
				}
				
				if (maximizingPlayer) {
					result.rank = -INFINITY_RANK;
					
					for (let x = 0; x < columns; x++) {
						let candidate = cloneTiles(tiles);
						
						if (!dropPiece(candidate, x, COMPUTER_CODE)) {
							continue;
						}
						
						let move = minimax(candidate, depth - 1, false, playerCode);
						
						if (move.rank > result.rank) {
							result.rank = move.rank;
							result.column = x;
						}
					}
					
					return result;
				} else {
					result.rank = INFINITY_RANK;
					
					for (let x = 0; x < columns; x++) {
						let candidate = cloneTiles(tiles);
						
						if (!dropPiece(candidate, x, USER_CODE)) {
							continue;
						}
						
						let move = minimax(candidate, depth - 1, true, playerCode);
						
						if (move.rank < result.rank) {
							result.rank = move.rank;
							result.column = x;
						}
					}
					
					return result;
				}
			}
			
			function doComputerMove(tiles, depth) {
				let ranks = minimax(tiles, depth, true, COMPUTER_CODE);
				dropPiece(tiles, ranks.column, COMPUTER_CODE);
				switchTurn();
				draw(tiles);
			}
			
			function check(tiles) {
				let winCode = 0;
				
				if (isPlayerWin(tiles, USER_CODE)) {
					winCode = USER_CODE;
				}
				
				if (isPlayerWin(tiles, COMPUTER_CODE)) {
					winCode = COMPUTER_CODE;
				}
				
				if (isDraw(tiles)) {
					winCode = DRAW_CODE;
				}
				
				if (winCode != 0) {
					setTimeout(function() {
						if (winCode == USER_CODE) {
							alert("User win");
						} else if (winCode == COMPUTER_CODE) {
							alert("Computer win");
						} else if (winCode == DRAW_CODE) {
							alert("Draw");
						}
						
						startNewGame();
					}, 1);
				}
				
				return winCode != 0;
			}
			
			function handleClick(event, tiles) {
				let rect = event.target.getBoundingClientRect();
				let mouseX = event.clientX - rect.left;
				let mouseY = event.clientY - rect.top;
				let x = Math.floor(mouseX / (frameWidth / columns));
				
				dropPiece(tiles, x, USER_CODE);
				
				if (check(tiles)) {
					return;
				}
				
				switchTurn(tiles);
				doComputerMove(tiles, 5);
				draw(tiles);
				check(tiles);
			}
			
			function startNewGame() {
				canvas.height = rows * 120;
				canvas.width = columns * 150;
				frameWidth = canvas.width;
				frameHeight = canvas.height;
				playerTurn = USER_CODE;
				
				let tiles = initialize();
				
				canvas.onclick = function(event) {
					event.stopPropagation();
					handleClick(event, tiles);
				};
				
				draw(tiles);
			}
			
			function main() {
				startNewGame();
			}
			
			main();
		</script>
	</body>
</html>
