<html>
	<head>
		<style>
			body {
				display: flex;
				align-items: center;
				justify-content: center;
				flex-direction: column;
				width: 100%;
				height: 100%;
				margin: 0;
				overflow: hidden;
			}
			#canvas {
				background: gray;
				color: white;
				border: 1px solid black;
			}
			#user_input {
				width: 100px;
				height: 100px;
				position: absolute;
				display: none;
				text-align: center;
				caret-color: transparent;
				font-family: "David";
				font-size: 20px;
				color: blue;
			}
			#user_input::-webkit-inner-spin-button {
				-webkit-appearance: none;
				margin: 0;
			}
		</style>
	</head>
	<body>
		<canvas id="canvas" width="600" height="600"></canvas>
		<input type="number" id="user_input"></input>
		<script>
			const TILES_GAP = 1;
			const BLOCK_TILE = 0;
			const NO_NUMBER = -1;
			const canvas = document.getElementById("canvas");
			const input = document.getElementById("user_input");
			const canvas2d = canvas.getContext("2d");
			
			let frameWidth = canvas.width;
			let frameHeight = canvas.height;
			let tiles = []
			let rows = 0;
			let columns = 0;
			let maxLength = 4;
			
			function initializeEmpty() {
				for (let y = 0; y < rows; y++) {
					let row = []
					
					for (let x = 0; x < columns; x++) {
						row.push({
							real_value: NO_NUMBER,
							user_value: NO_NUMBER
						});
					}
					
					tiles.push(row)
				}
			}
			
			function generateBorders() {
				for (let y = 0; y < rows; y++) {
					tiles[y][0].real_value = BLOCK_TILE;
				}
				
				for (let x = 0; x < columns; x++) {
					tiles[0][x].real_value = BLOCK_TILE;
				}
			}
			
			function generateIslands() {
				let y = 0;
				while (y < rows) {
					let x = Math.floor(randomInt(maxLength) / 2);
					while (x < columns) {
						generateIsland(x, y);
						x = Math.floor(x + randomInt(maxLength) / 2);
					}
					
					y = y + 1;
				}
			}
			
			function generateIsland(x, y) {
				if (isValidForBlock(x, y)) {
					tiles[y][x].real_value = BLOCK_TILE;
				}
				
				if (randomBoolean()) {
					if (isValidForBlock(x + 1, y)) {
						tiles[y][x + 1].real_value = BLOCK_TILE;
					}
					
					if (isValidForBlock(x, y + 1)) {
						tiles[y + 1][x].real_value = BLOCK_TILE;
					}
					
					if (isValidForBlock(x + 1, y + 1)) {
						tiles[y + 1][x + 1].real_value = BLOCK_TILE;
					}
				}
			}
			
			function isValidForBlock(x, y) {
				if (isOutside(x, y)) {
					return false;
				}
				
				if (isBlockMakeSingleCells(x, y)) {
					return false;
				}
				
				let oldValue = tiles[y][x].real_value;
				tiles[y][x].real_value = BLOCK_TILE;
				let numberOfIslands = calculateNumberOfIslands();
				tiles[y][x].real_value = oldValue;
				
				return numberOfIslands == 1;
			}
			
			function isBlockMakeSingleCells(x, y) {
				if (getTileValue(x - 1, y, BLOCK_TILE) != BLOCK_TILE &&
					getTileValue(x - 2, y, BLOCK_TILE) == BLOCK_TILE) {
					return true;
				}
				
				if (getTileValue(x + 1, y, BLOCK_TILE) != BLOCK_TILE &&
					getTileValue(x + 2, y, BLOCK_TILE) == BLOCK_TILE) {
					return true;
				}
				
				if (getTileValue(x, y - 1, BLOCK_TILE) != BLOCK_TILE &&
					getTileValue(x, y - 2, BLOCK_TILE) == BLOCK_TILE) {
					return true;
				}
				
				if (getTileValue(x, y + 1, BLOCK_TILE) != BLOCK_TILE &&
					getTileValue(x, y + 2, BLOCK_TILE) == BLOCK_TILE) {
					return true;
				}
				
				return false;
			}
			
			function calculateNumberOfIslands() {
				let islandsMap = []
				for (let y = 0; y < rows; y++) {
					let row = []
					
					for (let x = 0; x < columns; x++) {
						row.push(NO_NUMBER);
					}
					
					islandsMap.push(row)
				}
				
				let islandNumber = 1;
				
				for (let y = 0; y < rows; y++) {
					for (let x = 0; x < columns; x++) {
						if (islandsMap[y][x] != NO_NUMBER) {
							continue;
						}
						
						if (tiles[y][x].real_value == BLOCK_TILE) {
							continue;
						}
						
						islandsMap = markIsland(x, y, islandsMap, islandNumber);
						islandNumber = islandNumber + 1;
					}
				}
				
				return islandNumber - 1;
			}
			
			function markIsland(x, y, islandsMap, islandNumber) {
				if (isOutside(x, y)) {
					return islandsMap;
				}
				
				if (tiles[y][x].real_value == BLOCK_TILE) {
					return islandsMap;
				}
				
				if (islandsMap[y][x] != NO_NUMBER) {
					return islandsMap;
				}
				
				islandsMap[y][x] = islandNumber;
				islandsMap = markIsland(x + 1, y, islandsMap, islandNumber);
				islandsMap = markIsland(x - 1, y, islandsMap, islandNumber);
				islandsMap = markIsland(x, y + 1, islandsMap, islandNumber);
				islandsMap = markIsland(x, y - 1, islandsMap, islandNumber);
				return islandsMap;
			}
			
			function shortenLongRowsAndColumns() {
				for (let y = 0; y < rows; y++) {
					for (let x = 0; x < columns; x++) {
						if (tiles[y][x].real_value == BLOCK_TILE) {
							continue;
						}
						
						if (getLength(x, y, true) > maxLength) {
							if (!shortenRowOrColumn(x, y, true)) {
								return false;
							}
						}
						
						if (getLength(x, y, false) > maxLength) {
							if (!shortenRowOrColumn(x, y, false)) {
								return false;
							}
						}
					}
				}
				
				return true;
			}
			
			function getSum(x, y, isRow) {
				let result = 0;
				
				while (true) {
					if (isOutside(x, y)) {
						return result;
					}
					
					if (isBlock(x, y)) {
						return result;
					}
					
					result = result + tiles[y][x].real_value;
					
					if (isRow) {
						x = x + 1;
					} else {
						y = y + 1;
					}
				}
			}
			
			function getUserSum(x, y, isRow) {
				let result = 0;
				
				while (true) {
					if (isOutside(x, y)) {
						return result;
					}
					
					if (isBlock(x, y)) {
						return result;
					}
					
					result = result + tiles[y][x].user_value;
					
					if (isRow) {
						x = x + 1;
					} else {
						y = y + 1;
					}
				}
			}
			
			function getLength(x, y, isRow) {
				let result = 0;
				
				while (true) {
					if (isOutside(x, y)) {
						return result;
					}
					
					if (isBlock(x, y)) {
						return result;
					}
					
					result = result + 1;
					
					if (isRow) {
						x = x + 1;
					} else {
						y = y + 1;
					}
				}
			}
			
			function shortenRowOrColumn(x, y, isRow) {
				let length = getLength(x, y, isRow);
				let counter = 0;
				
				while (length > maxLength) {
					if (isRow) {
						generateIsland(x + randomInt(length), y);
					} else {
						generateIsland(x, y + randomInt(length));
					}
					
					length = getLength(x, y, isRow);
					
					if (counter++ > 100) {
						return false;
					}
				}
				
				return true;
			}
			
			function getTileValue(x, y, invalidValue) {
				if (isOutside(x, y)) {
					return invalidValue;
				}
				
				return tiles[y][x].real_value;
			}
			
			function isOutside(x, y) {
				return x < 0 || x >= columns || y < 0 || y >= rows;
			}
			
			function isBlock(x, y) {
				return tiles[y][x].real_value == BLOCK_TILE;
			}
			
			function fillNumbers() {
				for (let y = 0; y < rows; y++) {
					for (let x = 0; x < columns; x++) {
						if (tiles[y][x].real_value != NO_NUMBER) {
							continue;
						}
						
						if (!fillNumbersRecursively(x, y)) {
							return false;
						}
					}
				}
				return true;
			}
			
			function fillNumbersRecursively(x, y) {
				if (isOutside(x, y)) {
					return true;
				}
				
				if (tiles[y][x].real_value != NO_NUMBER) {
					return true;
				}
				
				let randomNumber = randomInt(maxLength) + 1;
				
				for (let i = 0; i < maxLength; i++) {
					candidate = ((randomNumber + i) % maxLength) + 1;
					
					if (!existsInRow(x, y, candidate) && 
						!existsInColumn(x, y, candidate)) {
						tiles[y][x].real_value = candidate;
						
						if (fillNumbersRecursively(x + 1, y)) {
							if (fillNumbersRecursively(x, y + 1)) {
								return true;
							}
						}
						
						tiles[y][x].real_value = NO_NUMBER;
					}
				}
				
				return false;
			}
			
			function existsInRow(x, y, number) {
				let curX = x;
				
				while (!isBlock(curX - 1, y)) {
					curX = curX - 1;
				}

				while (true) {
					if (isOutside(curX, y)) {
						return false;
					}
					
					if (isBlock(curX, y)) {
						return false;
					}
					
					if (tiles[y][curX].real_value == number) {
						return true;
					}
					
					curX = curX + 1;
				}
			}
			
			function existsInColumn(x, y, number) {
				let curY = y;
				
				while (!isBlock(x, curY - 1)) {
					curY = curY - 1;
				}
				
				while (true) {
					if (isOutside(x, curY)) {
						return false;
					}
					
					if (isBlock(x, curY)) {
						return false;
					}
					
					if (tiles[curY][x].real_value == number) {
						return true;
					}
					
					curY = curY + 1;
				}
			}
			
			function initialize() {
				let counter = 0;
				
				while (true) {
					tiles = []
					
					initializeEmpty();
					generateBorders();
					generateIslands();
					
					if (shortenLongRowsAndColumns()) {
						if (fillNumbers()) {
							console.log("success")
							break;
						} else {
							console.log("regenerate numbers")
						}
					} else {
						console.log("regenerate board")
					}
					
					if (counter++ > 1000) {
						break;
					}
				}
			}
			
			function tileWidth() {
				return (frameWidth - (TILES_GAP * (columns + 1))) / columns;
			}
			
			function tileHeight() {
				return (frameHeight - (TILES_GAP * (rows + 1))) / rows;
			}
			
			function tileLeft(x) {
				return (x * tileWidth()) + ((x + 1) * TILES_GAP);
			}
			
			function tileTop(y) {
				return (y * tileHeight()) + ((y + 1) * TILES_GAP);
			}
			
			function drawTile(x, y) {
				if (tiles[y][x].real_value == BLOCK_TILE) {
					canvas2d.fillStyle = "black";
					canvas2d.fillRect(tileLeft(x), tileTop(y), tileWidth(), tileHeight());
					
					let rowSum = getSum(x + 1, y, true);
					let colSum = getSum(x, y + 1, false);
					
					if (rowSum == 0 && colSum == 0) {
						return;
					}
					
					canvas2d.strokeStyle = "gray";
					canvas2d.beginPath();
					canvas2d.moveTo(tileLeft(x), tileTop(y));
					canvas2d.lineTo(tileLeft(x) + tileWidth(), tileTop(y) + tileHeight());
					canvas2d.stroke();
					
					if (rowSum != 0) {
						canvas2d.font = "15px David";
						canvas2d.fillStyle = "white";
						canvas2d.textAlign = "center";
						canvas2d.textBaseline = "middle";
						canvas2d.fillText(rowSum, tileLeft(x) + (tileWidth() / 2) + (tileWidth() / 4), tileTop(y) + (tileHeight() / 4));
					}
					
					if (colSum != 0) {
						canvas2d.font = "15px David";
						canvas2d.fillStyle = "white";
						canvas2d.textAlign = "center";
						canvas2d.textBaseline = "middle";
						canvas2d.fillText(colSum, tileLeft(x) + (tileWidth() / 4), tileTop(y) + (tileWidth() / 2) + (tileHeight() / 4));
					}
					
					return;
				}
				
				if (tiles[y][x].real_value == NO_NUMBER) {
					canvas2d.fillStyle = "#AAA";
					canvas2d.fillRect(tileLeft(x), tileTop(y), tileWidth(), tileHeight());
					return;
				}
				
				canvas2d.fillStyle = "white";
				canvas2d.fillRect(tileLeft(x), tileTop(y), tileWidth(), tileHeight());
				
				if (tiles[y][x].user_value != NO_NUMBER) {
					canvas2d.font = "20px David";
					canvas2d.fillStyle = "blue";
					canvas2d.textAlign = "center";
					canvas2d.textBaseline = "middle";
					canvas2d.fillText(tiles[y][x].user_value, tileLeft(x) + (tileWidth() / 2), tileTop(y) + (tileHeight() / 2));
				}
			}
			
			function draw() {
				canvas2d.clearRect(0, 0, frameWidth, frameHeight);
				
				for (let y = 0; y < rows; y++) {
					for (let x = 0; x < columns; x++) {
						drawTile(x, y);
					}
				}
			}
			
			function randomInt(max) {
				return Math.floor(Math.random() * max);
			}
			
			function randomBoolean() {
				return Math.floor(Math.random() * 2) == 0;
			}
			
			function handleClick(event) {
				let rect = event.target.getBoundingClientRect();
				let x = event.clientX - rect.left;
				let y = event.clientY - rect.top;
				let tileX = Math.floor(x / (frameWidth / columns));
				let tileY = Math.floor(y / (frameHeight / rows));
				
				if (tiles[tileY][tileX].real_value <= 0) {
					input.style.display = "none"
					return;
				}
				
				input.style.left = (rect.left + tileLeft(tileX)) + "px";
				input.style.top = (rect.top + tileTop(tileY)) + "px";
				input.style.width = tileWidth() + TILES_GAP * 2 + "px"
				input.style.height = tileHeight() + TILES_GAP * 2 + "px"
				input.value = ""
				input.style.display = "initial"
				input.attributes["selected"] = {
					x: tileX,
					y: tileY
				}
				input.focus()
			}
			
			function check() {
				for (let y = 0; y < rows; y++) {
					for (let x = 0; x < columns; x++) {
						if (isBlock(x, y)) {
							continue;
						}
						
						if (getSum(x, y, true) != getUserSum(x, y, true) ||
							getSum(x, y, false) != getUserSum(x, y, false)) {
							return;
						}
					}
				}
				
				alert("win");
			}
			
			function handleInputChange(event) {
				let selectedTile = input.attributes.selected
				tiles[selectedTile.y][selectedTile.x].user_value = parseInt(input.value)
				draw();
				check();
			}
			
			function startNewGame() {
				rows = 5;
				columns = 5;
				
				initialize();
				
				setTimeout(function() {
					canvas.height = rows * 40;
					canvas.width = columns * 40;
					input.height = rows * 40;
					input.width = columns * 40;
					frameWidth = canvas.width
					frameHeight = canvas.height
					draw();
				}, 1);
				
				canvas.onclick = function(event) {
					event.stopPropagation();
					handleClick(event);
				};
				
				input.onblur = function(event) {
					input.style.display = "none"
					input.attributes["selected"] = {}
				}
				
				input.onchange = function(event) {
					handleInputChange(event);
				}
			}
			
			function main() {
				startNewGame();
			}
			
			main();
		</script>
	</body>
</html>
